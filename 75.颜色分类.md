```cpp
// 复习
// 这题理论上并不难，就因为没有常规的套路可用，导致我居然没想出来。
// 因为要在原地tp，所以数组只能用给的nums，那么就要想到覆盖？覆盖不行，比如你[1 2]拿2覆盖1，那1咋整，可以
// 考虑用tmp，但这是否还算原地tp，有待商榷。另一个思路，就是swap，这点我是想到了的，[1 2]swap就是[2 1]，
// 给机会调整了顺序，还是原地tp，那么我们基于swap考虑。

// 说到swap，首先得熟悉其用法，swap俩指针，其实是交换其指向的内存，这没问题。那vector<int>里咋swap呢？是
// swap迭代器吗？可能没问题，但要熟悉其用法，swap(nums[i],nums[j])就直接交换这俩vector的数了，这点要明确。

// 然后，这题肯定是要for遍历的，遍历i过程处理，老生常谈了。其难就难在不只遍历一次（当然只遍历一次也行，但要
// 用到更复杂的算法，比如双指针等，这里就不考虑了先）。遇到问题，不要想太复杂了，既然一共就0 1 2排序，那就先
// 遍历一遍，遇到的所有0，都将其交换到vector的前面去；第一遍for走完，前面就全是0了，然后故技重施，从最后一个0
// 继续遍历一遍for，遇到的所有1都遍历到前面去，这就ok了。可见，在遍历的过程中，要有个idx要记录位置（官方题
// 解将其称之为指针ptr，其实没问题，因为作用是记录末尾0和末尾1的位置，好跟nums[i]进行交换用）。

// 我的错误思路：
// 上面就是正常的思路，这怎么会想不到呢？我当时是怎么想的？我想到了swap，然后想到首尾swap，但举例[2 1 0 1 2]
// 这样是行不通的。然后想到了选择冒泡排序之类的，两个指针，pre和cur前后swap，但发现一轮下来不行，离正确结果
// 还较远，所以就放弃了。这里补充一点，应当去把冒泡、选择、快排等基础排序再搞清楚一下。

// 如果形成正确思路：
// 既然已经想到了swap方便原地tp，那么不考虑太复杂，怎么才能题干一步到位呢？怎么才能swap一次前面就有一个0呢？
// 那就是遇到0就swap到前面去！想到这一步这题基本就解出来了。

// 由于此题的数较小较简单，所以其实还有取巧解法。那就是遍历for一遍，统计所有的0、1、2的个数。然后再遍历for
// 整个数组，将其进行覆盖重写，先写0、再写1、最后写2。这也是一种正确的、简单的、取巧的解法！当想不到常规思路
// 时，如果题干数不复杂，应该想想有没有取巧解法！

class Solution {
public:
    void sortColors(vector<int>& nums) {
        // swap位置记录指针，用于记录遍历for过程中，vector前面交换得来的0，已经到哪来了；
        // swap 1时同理，基于最后一个0继续前进即可。
        int idx = 0;
        // 两层for遍历，第一遍把所有的0 swap到前面去，第二遍把所有的1遍历到0后面的前面去，最后就剩2了。
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] == 0) {
                swap(nums[i], nums[idx]);
                // 优化写法，idx可写成nums[idx++]。
                idx++;
            }
        }

        for (int i = idx; i < nums.size(); i++) {
            if (nums[i] == 1) {
                swap(nums[i], nums[idx]);
                idx++;
            }
        }
    }
};
```

![image-20221027213958731](https://hanbabang-1311741789.cos.ap-chengdu.myqcloud.com/Pics/image-20221027213958731.png)

![image-20221027213922902](https://hanbabang-1311741789.cos.ap-chengdu.myqcloud.com/Pics/image-20221027213922902.png)