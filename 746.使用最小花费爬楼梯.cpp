动态规划

思路：动归题思路一般确定五部曲的前三部最重要。需要想到dp[i]的含义代表当前坐标i位置的累积最低消费，
然后确定递推公式，要么是dp[i-1]，要么是dp[i-2]，然后抽象成min(dp[i-1], dp[i-2])，此为难点。

动归五部曲：
1）确定dp数组及下标的含义。和“62.不同路径”类似，上来直接先考虑题干问题，终点的最低消费，能否直接用dp[last]
cover住呢？此题其实可以，直接用dp[i]代表“当前位置的最低消费”，则dp[last]自然就是终点的最低消费，
dp数组的长度自然也确定，即和cost[]一样长度。其实本题题意结合数组有些抽象，但宗旨不变就问题不大。
2：确定递推公式。如思路给出，“考虑当前dp[i]应当如何得到?一般是前面的dp[i-1]、dp[i-2]之类的某种组合操作”，
按照此题意思，dp[i]应当由dp[i-1]或dp[i-2]得到，因为“代表的当前累积消费”，所以既然dp[i-1]和dp[i-2]都能直接跨到dp[i]，
自然选它俩较小者，即min(dp[i-1], dp[i-2])。本题是dp[i]=min(dp[i-1], dp[i-2])+cost[i]，是因为本题题意抽象导致的，
其实就是如果要确定dp[i]，那必须“这会把i位置也算上（即使cost[i]很大）”，但这么做实际上到“最后两格”就会发现，
这是“先算上，最后好选择”的意思，因为“最后两格，都可以直接支付后登顶”，这点确实也是本题的特殊之处，不太容易理解。
3：初始化dp数组。按照1）2）的思路，则可确定dp[0]、dp[1]初始值为cost[0]、cost[1]，刹一看有违和感，但考虑到dp[i]必须
要把当前位置算上（即使cost[i]很大，好像亏了），实际就可以理解了。为何这里是初始化dp[0]、dp[1]？因为递推公式提到了dp[i]需要
dp[i-1]、dp[i-2]，所以初始化dp[0]、dp[1]也是合理的。
4：确定遍历顺序。常规的从前往后。
5：举例推导dp数组。

class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int n = cost.size();
        vector<int> dp(n, 0);
        dp[0] = cost[0];
        dp[1] = cost[1];
        for (int i = 2; i < n; i++) {
            dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];
        }
        return min(dp[n - 1], dp[n - 2]);
    }
};