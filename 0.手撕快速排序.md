```cpp
// 1. 选定pivot中心轴
// 2. 将大于pivot的数字，放在pivot右边
// 3. 将小于pivot的数字，放在pivot的左边
// 4. 分别对左右子序列，重复上述3步

// 复杂度分析：可见，每次递归处理的子序列，大约看做都会缩短为之前1/2，直到缩短为0/1不做处理。这类似二分法的复杂度，是logn。
// 此外，对于递归内部，每个子序列的while处理让left++、right--遍历子序列，大约是n的复杂度。所以快排复杂度为：nlogn。

void QuickSort(vector<int>& nums, int left, int right) {
    // 递归终止条件：经测试可发现，比如当前序列为[2 3]，这次循环交换处理完后，left=right=0,pivot=2。
    // 进入下次递归，左序列为[0,-1]（意味着左序列长度为0），右序列为[1,1]（意味着右序列长度为1）。
    // 这两种情况都应该终止，所以left=right，left<right都可能出现。
    // 注：不要用nums==1来判断终止，因为nums其实长度从来没变过，一直传的完整的长度。只是其内容会变，传的引用进来。
    if (left >= right) {
        return;
    }

    // 记录进入当前序列时，其左右边界，后面进入下次递归时会用到，确定下次递归时，子序列的左右边界值。
    // 记录的原因，主要是left、right会在当前序列的交换过程中移动变化，所以要记录个初始不变值。
    int ori_left = left;
    int ori_right = right;

    // 将当前序列的最左，作为pivot。
    // 注意，pivot一定是val而非idx，否则由于后续的交换，nums[pivot]是会变的！
    int pivot = nums[left];

    // 对当前序列进行while循环处理，主要就是一直和pivot比大小，left++、right--，最后让left=right出循环。
    // 注意，里面的每个处理都判断left<right，因为一旦left=right，就是当前序列排完、给pivot确定位置(left or right)的时候了。

    // 简单来说，先处理right，如果不满足就一直right--，满足就交换去left。然后处理left，如果不满足就一直left++，满足就交换去right。
    // 如此往复，从代码的角度，这种交换就应该是以下形式：
    // while (left < right) {
    //     right...;
    //     left...;
    // }

    while (left < right) {
        // 如果pivot<=right，那就持续right--。
        while (left < right && pivot <= nums[right]) {
            right--;
        }

        // 直到pivot>right，则需要将right赋值到pivot左边，即当前left位置。
        if (left < right) {
            nums[left] = nums[right];
            // 这步可以省略，因为当right赋值到left后，即使left不++，
            // 也马上就轮到left与pivot比较，此时left自然小于pivot（不然不会被交换过来），就会直接left++，相当于执行了这步。
            // left++;
        }

        // 如果left<=pivot，那就持续left++。
        while (left < right && nums[left] <= pivot) {
            left++;
        }

        // 直到left>pivot，则需要将left赋值到pivot右边，即当前right位置。
        if (left < right) {
            nums[right] = nums[left];
            // 与上面同理。
            // right--;
        }
    }

    // 此时，left=right。
    // cout<<"l:"<<left<<" r:"<<right<<endl;

    // 每轮交换结束后，以left=right作为标志，此时将标志值pivot，置于这个靠中间的位置。
    nums[left] = pivot;
    // 对左、右子序列分别进行递归。
    // 关注递归的参数：nums（长度不变，内容每次逐渐变化）；left、right描述递归的移动，描述子序列的边界。
    QuickSort(nums, ori_left, right - 1);
    QuickSort(nums, right + 1, ori_right);
}

// 复习
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

void QuickSort(vector<int>& nums, int left, int right) {
    if (left >= right) {
        return;
    }

    int ori_left = left;
    int ori_right = right;

    int pivot = nums[left];

    while (left < right) {
        while (left < right && pivot < nums[right]) {
            right--;
        }
        if (pivot > nums[right]) {
            nums[left] = nums[right];
            left++;
        }
        while (left < right && nums[left] < pivot) {
            left++;
        }
        if (nums[left] > pivot) {
            nums[right] = nums[left];
            right--;
        }
    }

    nums[left] = pivot;
    QuickSort(nums, ori_left, left - 1);
    QuickSort(nums, left + 1, ori_right);
}

int main() {
    vector<int> nums = {19, 3, 8, 6, 12, 15};
    for_each(nums.begin(), nums.end(), [&](int val){cout << val << " ";});
    cout<<endl;
    QuickSort(nums, 0, nums.size() - 1);
    for_each(nums.begin(), nums.end(), [&](int val){cout << val << " ";});
    return 0;
}
```cpp

用**图文并茂**的方式，把快速排序（QuickSort）讲得特别容易理解。
而且，是的——快速排序就是\*\*分治法（Divide and Conquer）\*\*的经典例子。

---

## 1️⃣ 快速排序的思想

一句话概括：

> **选一个基准值（pivot） → 把比它小的放左边，比它大的放右边 → 再对左右两边重复同样的操作**

这就是“**分治法**”的套路：

* **分**（Divide）：把数组分成两部分
* **治**（Conquer）：递归地分别排序两部分
* **合**（Combine）：快速排序里，不用显式合并，因为分区操作后自然有序

---

## 2️⃣ 用一个例子看过程

假设我们要排序：

```
[5, 2, 9, 1, 7]
```

---

### 第一步：选一个基准值（pivot）

假设我们选第一个数 `5` 作为 pivot。

```
pivot = 5

[ 5, 2, 9, 1, 7 ]
  ^
```

---

### 第二步：左右指针移动

* 左指针从左往右找**比 pivot 大的数**
* 右指针从右往左找**比 pivot 小的数**
* 找到后交换，直到左右指针相遇

过程：

1️⃣ **右指针**向左找比 5 小的数 → 找到 `1`
2️⃣ **左指针**向右找比 5 大的数 → 找到 `9`
3️⃣ 交换：

```
[ 5, 2, 1, 9, 7 ]
```

---

4️⃣ 再找：

* 右指针向左找比 5 小的 → 找到 `2`
* 左指针向右找比 5 大的 → 找到 `7`
* 交换：

```
[ 5, 2, 1, 4, 7 ]  ❌(这里我例子没用4，是举例思路)
```

直到左右指针相遇。

---

### 第三步：放回 pivot

当左右指针相遇，把 pivot 放在中间位置：

```
[ 2, 1, 5, 9, 7 ]
        ^
```

此时：

* 左边 `[2, 1]` 都 ≤ 5
* 右边 `[9, 7]` 都 ≥ 5

---

### 第四步：递归处理左右两边

左边 `[2, 1]`：

```
pivot = 2
交换后 → [1, 2]
```

右边 `[9, 7]`：

```
pivot = 9
交换后 → [7, 9]
```

---

### 第五步：合并结果（其实就是自然拼回）

```
[1, 2, 5, 7, 9]
```

排序完成 ✅

---

## 3️⃣ 快速排序的流程图

```
             [5, 2, 9, 1, 7]
                     |
                  pivot=5
         ┌───────────┴───────────┐
 [2, 1] (≤5)                 [9, 7] (≥5)
     |                           |
 pivot=2                      pivot=9
     |                           |
 [1]   [2]                   [7]   [9]
```

---

## 4️⃣ 快速排序是分治吗？

是的，而且非常标准：

* **分（Divide）**：通过 pivot 把数组分成左右两部分
* **治（Conquer）**：递归对左右两边排序
* **合（Combine）**：左右部分本来就在 pivot 的两侧，不需要额外合并

---

## 5️⃣ 你的代码的小细节

你这段代码用的也是**左右指针法**，逻辑是：

1. pivot 选第一个元素
2. 从右边找比 pivot 小的，放到左边空位
3. 从左边找比 pivot 大的，放到右边空位
4. 循环直到 left == right
5. 把 pivot 放回去，然后递归左右区间

它的优势：

* **原地排序**（不需要额外数组）
* 平均时间复杂度 `O(n log n)`
* 最坏情况 `O(n²)`（比如数组已经有序且每次 pivot 选到最小/最大）

---

如果你愿意，我可以帮你画一个**你这段代码运行的完整动画图**，每一步 left/right 移动的变化都会标出来，这样你就能一眼看懂指针是怎么走的。
这样会比文字还直观。

