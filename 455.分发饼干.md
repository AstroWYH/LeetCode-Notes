```cpp
// 复习
// 贪心算法的代表题之一，在一次for遍历的过程中，每次都有个处理方式，达到局部最优，最终for循环遍历
// 完成后，达到全局最优。

// 此题题干读起来有点拗口，结合示例看更容易快速理解题意。拿到题后，上来比较容易懵圈，需要首先捕获几个关键信息
// 比如s[j]>=g[i]，就是说饼干要满足孩子胃口，那么大概率这个题需要遍历孩子g或饼干s，在遍历过程中比较，题干
// 最后一句“尽可能满足越多数量的孩子”，那就是可能还有个for外的全局cnt，来统计最大孩子数。

// 然后思考遍历，给了2个数组，那是遍历孩子g，还是遍历饼干s呢？现在举例（不用示例，是感觉示例太短不够形象）：
// 孩子：[1 2 5 6 7]
// 饼干：[1 2 3 5 7]
// 【注意】这是举例，当然可能孩子多饼干少，也可能孩子少饼干多，初期不用思考这些，当能随便举例后思考得到一个看
// 起来合理的写法，并提交能通过一些例子后，再去思考谁长谁短，以及一些特殊例子的边界判断也不迟。

// 回到例子，如果遍历孩子，那么for循环处理过程中，满足的孩子算上，让cnt++，不满足的不算，遍历结束就得到答案，
// 看起来比较合理。如果遍历饼干，那有的饼干发出去了，有的可能没发出去，这能得到个啥？所以两相对比，我们选择
// 遍历孩子。

// 然后，如何遍历孩子？由题意可知，这个题是要遍历过程比大小，然后取得适当匹配的结果，那么可能会想到，应该是要
// 先排序，比如孩子、饼干都排成升序数组，这样遍历过程中，才好比大小。因为脑海中大概过一下，大不了就是两个
// 遍历过程一起走，如果完美匹配，就齐头并进，如果有的不满足，就稍微错开一点走，虽然还是不够形象，但大概有点
// 这个意思。这里题目给的示例1、2都太短，可稍微自己想长一点的例子，会有感觉一点。
// 换个角度思考，这个题如果答案已知，那把2个数组上下一放，其实就是个连线问题，可能有点直线，可能有点斜线，
// 可能有的没有线连。

// 大概明白题意后，考虑下如何遍历？还是看上述例子，如果升序（从左到右）遍历，那1-1 2-2 5-5，可见，5-5的连线
// 就斜了，遍历到孩子5的时候，下面的饼干3不满足，再下个饼干5才满足，但如果该饼干不是5，而该5在很后面位置（即
// 中间还又隔了一堆饼干）才出现，那岂不是意味着，孩子5要想找到>=5的这个饼干5，要往后遍历一大堆饼干，并且，
// 此后的每一个孩子，都可能遇到这样的问题，复杂度很大，也不好处理。
// 此外，即便是前面的1-1 2-2，处理起来也有点别扭，因为对于孩子1，其实下面所有的饼干都是满足的，所以要找的是
// >=1的第一个饼干，想想也是有点麻烦。

// 那么，对于这个问题，我们要想到，对于两头（孩子1和孩子7）而言，孩子1其实是最好养的，你给他1也能养活，你给他
// 7，也能养活；而反观孩子7，就有点难养活了，对于当前所有饼干，你只有给他7才能养活他。基于上述，所以可以考虑
// 下，是不是先把孩子7搞定，再来搞孩子1，毕竟孩子1好养，就算7-7了，那1-？还有多种方式，只是？不等于7了而已。
// 而反过来，如果万一先拿7搞定孩子1，即1-7，那孩子7就没吃的了，这样就不满足“尽量越多孩子有吃的”的条件！

// 基于此，我们先猜测搞定胃口大的，这样很可能可以满足尽量多的孩子有吃的。有想法，感觉合理，就可以实施，不用要
// 100%要通才动手。那么此时，我们反向遍历上述两个数组：
// 孩子：[1 2 5 6 7]
// 饼干：[1 2 3 5 7]
// 反向遍历孩子g，也拿最大的饼干，跟孩子7来比，一看满足，那么把孩子7和饼干7都踢掉；又来比孩子6和饼干5，一看
// 不满足，然而当前饼干5是最大的饼干了，毕竟饼干7已经踢掉了，要是拿孩子6换回饼干7来吃，那显然感觉更不合理。
// 综上呢，孩子6就没吃的了；所以只能继续遍历孩子5，而饼干5没做处理，所以此时，孩子5就可以取饼干5吃了，此时
// 就连了一条斜线。
// 到此，大概思路就理出来了，怎么实现呢？显然，遍历孩子就直接拿for倒着遍历g数组，而在此过程中，饼干也要遍历，
// 就有点点像快慢双指针，孩子i每次都i--，而饼干j（考虑为j）只有for内特定条件才j--，什么条件？那就是当前孩子，
// 和当前最后一个饼干（也是当前最大饼干）比，要g[i]<=s[j]才行。行，就都继续往左走，即i--、j--，且cnt++，对
// 吃上饼干的孩子计数；不行，就只孩子往左走，即i--，j不动，也不计数。到此，此题核心思路就描述完成！

class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        // 毕竟是两个数组遍历过程中，还要比大小，想想就还是先排序合适。
        sort(g.begin(), g.end());
        sort(s.begin(), s.end());
        // 大致思路整好，提交对一部分，有特殊报错的时候，处理边界条件。
        // 这里就是如果饼干数量为0，后面j=-1访问是会出错的。
        if (s.size() == 0) return 0;
        // 经典cnt，记录题干问题（最后一句），遍历过程中累加满足条件的孩子数，最后得到最大孩子数。
        int cnt = 0;
        // 饼干s数组也跟着倒着遍历，拿到for外定义，其实类似快慢双指针的slow。
        int j = s.size() - 1;
        // 孩子g数组正常倒序遍历，类似快慢双指针的fast。
        for (int i = g.size() - 1; i >= 0; i--) {
            // j>=0这个边界条件一开始想不到正常，后面提交时，特殊例子报错处理了。
            // j>=0是因为，如果饼干太少，孩子没遍历完饼干就吃完了，那j--到-1了，s[j]肯定报错。
            // 其实就是i、j一起遍历，i有i>=0边界保护，j当然也得有才行。毕竟g、s数组谁先遍历完都有可能。
            // g[i]<=s[j]，就是for内满足条件，要当前遍历的孩子胃口<=当前最后一个(最大)饼干才满足，
            // 不满足只有跳过该孩子继续往左遍历，毕竟当前没有更大的饼干给你吃了。
            // （更大的已剔除，也喂了更大的孩子，起了作用，不可能给你）
            if (j >= 0 && g[i] <= s[j]) {
                // 经典计数，吃得上饼干的孩子。
                cnt++;
                // 满足条件，饼干剔除，也继续往左走。
                j--;
            } else {
                // g[i] > s[j]，当前饼干不能满足小孩，小孩往前（胃口更小方向）遍历
                // 该else方便理解放这，应该删除。
            }
        }
        // 返回累计的，所有吃得上饼干的孩子。
        return cnt;
    }
};

// 复习

// 普通例子
尺寸s = [2 4 5]
胃口g = [1 2 6]

// 需要给j>=0判空
尺寸s = [2 4 5]
胃口g = [1 2 3 4]

// 需要排序
s = [5,6,7,8]
g = [10,9,8,7]

class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {

        sort(g.begin(), g.end());
        sort(s.begin(), s.end());

        int max_ans = 0;
        // 类似快慢双指针。
        int j = s.size() - 1;
        // 题干最终是选孩子g，所以遍历孩子数组g。
        for (int i = g.size() - 1; i >= 0; i--) {

            // if条件里是，g中哪些孩子能被选中。
            // 对每个孩子都进行判断（筛选），看是否当前有饼干可以满足。
            if (j >= 0 && s[j] >= g[i]) {
                max_ans++;
                j--;
            }
        }

        return max_ans;
    }
};

贪心算法

思路：每次遍历“尽量大饼干喂饱大胃口小孩”，核心是两个错落满足的的数组，画出2个数组的图。
每个小孩（遍历对象）从后到前（从大到小），尽量去取大饼干（从后到前）吃，此为局部最优，整个遍历逐渐全局最优。
经考虑，任何一种遍历方式，如“遍历小饼干尽量优先喂小胃口”，或“遍历小胃口尽量优先吃小饼干”，
“估计”都可以解此题。

注：如果小孩太多g>s，则for一直遍历到结束，但是if不会进了，因为饼干没了index不满足，或饼干太小不满足；
如果饼干太多g<s，则for小孩遍历完就结束了。
可见，以小孩g为主要for遍历对象，饼干s只是通过index下标跟随，这是经典的手法，否则如果2层for就很不好了。
注意理解上述的点，因为一旦选择认定了小孩g无论如何都每次过1个，所以用for遍历，而饼干则随着小孩g遍历不一定
每次发得出去（比如遍历的小孩g[i]比当前最大饼干s[index]大时），因此作为if限定内的index--，这是常用的思路。

注：选定一方（小孩）for遍历i，另一方用index跟随，这是关键的思路。
注：这个index实际上相当精髓，好好理解，否则需要两重循环。
注：此题搭配图解理解更佳，P308。

class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        sort(g.begin(), g.end()); // g为小孩
        sort(s.begin(), s.end()); // s为饼干
        int result = 0;
        int index = s.size() - 1;
        for (int i = g.size() - 1; i >= 0; i--) {
            if (index >= 0 && s[index] >= g[i]) {
                result++;
                index--;
            }
        }
        return result;
    }
};
```

![image-20221020225542219](https://hanbabang-1311741789.cos.ap-chengdu.myqcloud.com/Pics/image-20221020225542219.png)

![image-20221020225558266](https://hanbabang-1311741789.cos.ap-chengdu.myqcloud.com/Pics/image-20221020225558266.png)